# -*- coding: utf-8 -*-
"""Proyek_Pertama_Predictive_Analytics

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hiufDhqyVyaSy19XalLMpV8Wf2eM82ML

# 1. Mengimpor Library

Pada tahap ini, kita mengimpor seluruh library yang diperlukan, seperti numpy, pandas, seaborn, matplotlib, dan sklearn.
"""

import textwrap
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from xgboost import XGBClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import GridSearchCV, RandomizedSearchCV, train_test_split
from sklearn.preprocessing import LabelEncoder, OrdinalEncoder, OneHotEncoder
from sklearn.metrics import ConfusionMatrixDisplay, accuracy_score, classification_report

"""# Data Loading

Selanjutnya, kita melihat isi dari dataset secara sekilas dengan `.head()` dan ukuran dari dataset dengan `.shape`
"""

data = pd.read_csv("/content/ObesityDataSet.csv")

# Menampilkan ukuran data
print(data.shape)

# Melihat 5 baris pertama data
data.head()

"""Dari hasil di atas, diperoleh dataset tersebut memiliki 2111 baris dan 17 kolom.

# Deskripsi Variabel

## Arti Variabel

Berikut adalah arti dari variabel-variabel pada dataset tersebut.

Variabel | Keterangan
----------|----------
Gender | Jenis kelamin responden (laki-laki atau perempuan)
Age | Usia responden
Height | Tinggi responden (dalam satuan meter)
Weight | Berat responden (dalam satuan kilogram)
family_history_with_overweight | Apakah terdapat anggota keluarga responden yang juga terkena obesitas
FAVC | Apakah responden mengonsumsi makanan berkalori tinggi
FCVC | Frekuensi konsumsi sayur-sayuran dalam sehari
NCP | Frekuensi konsumsi makanan berat dalam sehari
CAEC | Konsumsi makanan di antara makan berat
SMOKE | Apakah responden merupakan perokok atau tidak
CH2O | Frekuensi Konsumsi air dalam sehari (dalam satuan liter)
SCC	| Apakah responden memantau asupan kalori
FAF	| Frekuensi aktivitas fisik dalam seminggu (0 = Tidak pernah, 1 = 1-2 hari, 2 = 3-4 hari, 3 = 5-6 hari)
TUE	| Waktu pemakaian gadget dalam sehari (0 = 0-3 jam, 1 = 4-6 jam, 2 = 6+ jam)
CALC | Frekuensi konsumsi alkohol
MTRANS | Jenis transportasi yang digunakan
NObeyesdad | Tingkat berat badan responden

## Memeriksa Tipe Variabel Beserta Jumlah
"""

data.info()

"""Dapat dilihat bahwa terdapat 8 variabel bertipe `float64` dan 9 variabel bertipe `object`.

## Menampilkan Deskripsi Statistik dari Data
"""

data.describe()

"""Dari hasil tersebut, dapat disimpulkan bahwa responden memiliki rentang usia 14-61 tahun dengan tinggi rentang 1.45-1.98 meter dan berat rentang 39-173 kilogram.

# Data Cleaning

## Memeriksa Nilai yang Kosong pada Data
"""

pd.DataFrame({'Nilai yang Kosong':data.isnull().sum()})

"""Dari hasil di atas, tidak ada variabel yang memiliki nilai `null` atau kosong.

## Memeriksa Duplikasi Data
"""

data.duplicated().sum()

"""Terlihat bahwa terdapat 24 duplikasi data pada data ini. Akan diperiksa apakah duplikasi data ini perlu diperbaiki atau dihapus."""

# Menampilkan data duplikat
data[data.duplicated]

"""Dari hasil di atas, terlihat bahwa ada data-data tersebut memang terduplikasi. Oleh karena itu, data duplikat ini akan dihapus."""

data.drop_duplicates(inplace = True)

"""Selanjutnya, akan dilihat info dan deskripsi statistik dari data yang telah dibersihkan."""

data.info()

data.describe()

"""## Visualisasi Data

Akan digunakan boxplot untuk melihat persebaran data pada masing-masing kolom.
"""

# Menuliskan seluruh nama kolom numerikal
kolom_data = ["Age", "Weight", "Height", "FCVC", "NCP", "CH2O", "FAF", "TUE"]

# Membentuk plot berukuran 24 x 12
plt.figure(figsize = (24, 12))

# Membentuk plot berisi 8 subplot, dengan setiap subplot merupakan boxplot
for i in range(len(kolom_data)):

    # Membentuk plot dengan subplot berukuran 4 x 2
    plt.subplot(4, 2, i + 1)
    sns.boxplot(x = data[kolom_data[i]])
    plt.title('Boxplot dari {}'.format(kolom_data[i]))
    plt.tight_layout()

"""Berikut adalah interpretasi dari boxplot di atas.
1. Pada kolom `Age`, dapat dilihat bahwa mayoritas responden berusia di rentang 20-30 tahun. Terdapat beberapa outlier, yaitu usia 50 tahun ke atas. Meski demikian, outlier ini tidak akan dihapus karena sangat memungkinkan seseorang berusia 50 tahun ke atas.
2. Pada kolom `Weight`, dapat dilihat bahwa mayoritas responden memiliki berat badan di rentang 60-110 kilogram. Terdapat 1 outlier, yaitu responden dengan berat badan 173 kilogram. Meski demikian, outlier ini tidak akan dihapus karena sangat memungkinkan seseorang memiliki berat badan 173 kilogram.
3. Pada kolom `Height`, dapat dilihat bahwa mayoritas responden memiliki tinggi badan di rentang 1,6-1,8 meter. Terdapat 1 outlier, yaitu responden dengan tinggi badan 1,98 meter. Meski demikian, outlier ini tidak akan dihapus karena sangat memungkinkan seseorang memiliki tinggi badan 1,98 meter.
4. Pada kolom-kolom lainnya, dapat dilihat bahwa persebaran data merata dan tidak terdapat outlier yang signifikan.

Untuk proses analisis ini, outlier tidak akan dibuang karena sangat memungkinkan responden termasuk dalam outlier tersebut. Data sudah siap untuk diproses dan dianalisis.

# Univariate Analysis

Pertama, kita akan membagi variabel-variabel yang ada menjadi 2 kategori, yaitu kategori numerikal dan kategori kategorical.
"""

# Membentuk list berisi kolom-kolom numerikal (data yang bertipe float64)
kolom_numerikal = [nama_kolom for nama_kolom in data if data[nama_kolom].dtype == "float64"]

# Membentuk list berisi kolom-kolom kategorikal (data yang bertipe object)
kolom_kategorikal = [nama_kolom for nama_kolom in data if data[nama_kolom].dtype == "object"]

# Menampilkan list kolom numerikal dan kolom kategorikal
print("Kolom-kolom numerikal: ", kolom_numerikal)
print("Kolom-kolom kategorikal: ", kolom_kategorikal)

"""Selanjutnya, kita akan melihat nilai-nilai pada kolom kategorikal."""

# Menghitung jumlah nilai yang unik/berbeda dari masing-masing variabel pada kolom kategorikal
jumlah_unik = data[kolom_kategorikal].nunique()

# Menampilkan nilai yang unik/berbeda dari masing-masing variabel pada kolom kategorikal
nilai_unik = data[kolom_kategorikal].apply(lambda x: x.unique())

# Menampilkan hasil dalam bentuk DataFrame
pd.DataFrame({"Total Nilai Berbeda": jumlah_unik, "Nilai-Nilai": nilai_unik})

"""Selanjutnya, kita akan melihat jumlah dari masing-masing nilai pada hasil di atas."""

# Membentuk plot dengan subplot sejumlah 9 berukuran 3 x 3
fig, axes = plt.subplots(3, 3, figsize = (18, 18))

# Mengubah array multi dimensi menjadi array 1 dimensi
axes = axes.flatten()

# Mendeskripsikan kolom-kolom kategorikal yang akan digunakan
deskripsi_kolom_kategorikal = ["Jenis Kelamin",
                               "Riwayat Obesitas Dalam Keluarga",
                               "Konsumsi Makanan Berkalori Tinggi",
                               "Konsumsi Makanan Di Antara Makan Berat",
                               "Merupakan Perokok",
                               "Memantau Asupan Kalori",
                               "Mengonsumsi Alkohol",
                               "Jenis Transportasi yang Digunakan",
                               "Tingkat Berat Badan"]

# Membentuk plot jumlah dalam bentuk bar plot untuk masing-masing kolom
for i, kolom in enumerate(data[kolom_kategorikal].columns):
    sns.countplot(x = kolom, data = data, ax = axes[i], hue = kolom)

    # Menambahkan judul untuk masing-masing plot
    judul = "\n".join(textwrap.wrap(f"Plot Jumlah dari {deskripsi_kolom_kategorikal[i]}", width = 40))
    axes[i].set_title(judul)
    axes[i].title.set_size(12)

    # Mengatur label x
    axes[i].tick_params(axis = "x", labelrotation = 90)
    axes[i].tick_params(axis = "both", which = "major", labelsize = 12)
    axes[i].set_xlabel("")

# Mengatur susunan agar tidak berhimpitan
plt.tight_layout()

# Menampilkan plot
plt.show()

"""Gambar di atas dapat diinterpretasikan sebagai berikut.
1. Dari `Plot Jumlah dari Riwayat Obesitas Dalam Keluarga`, mayoritas responden memiliki riwayat obesitas dalam keluarganya.
2. Dari `Plot Jumlah dari Frekuensi Konsumsi Makanan Berkalori Tinggi`, mayoritas responden memakan makanan berkalori tinggi.
3. Dari `Plot Jumlah dari Konsumsi Makanan Di Antara Makan Berat`, mayoritas responden memakan makanan seperti cemilan atau snacks di antara makan berat.
4. Dari `Plot Jumlah dari Perokok atau Bukan`, mayoritas responden bukanlah perokok.
5. Dari `Plot Jumlah dari Memantau Asupan Kalori`, mayoritas responden tidak memantau asupan kalori mereka masing-masing.
6. Dari `Plot Jumlah dari Mengonsumsi Alkohol`, sebagian besar responden terkadang minum alkohol dan sebagian kecil responden tidak meminum alkohol.
7. Dari `Plot Jumlah dari Jenis Transportasi yang Digunakan`, mayoritas responden menggunakan transportasi umum sebagai sarana transportasi mereka
8. Dari `Plot Jumlah dari Tingkat Berat Badan`, persebaran tingkat level berat badan cukup merata, dengan Obesitas tipe 1 merupakan jumlah yang paling banyak dialami responden.

Selanjutnya, kita akan melihat lebih detail mengenai jumlah dari masing-masing tingkat berat badan untuk mengetahui jumlah secara umum.
"""

tingkat_berat = data.NObeyesdad.value_counts()
tingkat_berat

"""Secara total, dapat dilihat bahwa responden yang mengalami berat badan berlebih maupun obesitas berjumlah 1538 orang dari 2087 orang.

Selanjutnya, akan dibuat pie chart untuk melihat persebaran data dari masing-masing tingkat berat badan.
"""

# Membuat variabel label dan size
label = tingkat_berat.index.tolist()
size = tingkat_berat.values.tolist()

# Membentuk pie chart untuk melihat persebaran data dari masing-masing tingkat berat badan
plt.figure(figsize = (8, 8))
plt.pie(size, labels = label, autopct = "%1.1f%%", startangle = 140, radius = 0.75)

# Menambahkan legend pada pie chart
plt.legend(loc = "upper left", bbox_to_anchor = (1, 1))

# Menambahkan judul pada plot
plt.title("Distribusi Tingkat Berat Badan")

# Menampilkan plot
plt.show()

"""Dari gambar di atas, total responden yang mengalami berat badan berlebih maupun obesitas berjumlah $73.7\%$, dengan $46.5\%$ di antaranya mengalami obesitas.

Selanjutnya, kita akan membentuk histogram dari variabel-variabel numerikal untuk melihat persebaran data.
"""

# Membentuk plot dengan subplot sejumlah 8 berukuran 2 x 4
fig, axes = plt.subplots(2, 4, figsize = (15, 8))

# Mengubah array multi dimensi menjadi array 1 dimensi
axes = axes.flatten()

# Menambahkan satuan dari masing-masing kolom
labels = ["Tahun", "Meter", "Kilogram", "Liter", "Frekuensi", "Jumlah", "Kategori", "Kategori"]

# Mendeskripsikan kolom-kolom numerikal yang akan digunakan
deskripsi_kolom_numerikal = ["Usia",
                             "Tinggi Badan",
                             "Berat Badan",
                             "Frekuensi Konsumsi Air Harian",
                             "Frekuensi Konsumsi Sayur-Sayuran Harian",
                             "Frekuensi Konsumsi Makanan Berat",
                             "Frekuensi Aktivitas Fisik",
                             "Lama Pemakaian Gadget"]

# Membentuk plot jumlah dalam bentuk histogram plot untuk masing-masing kolom
for i, kolom in enumerate(data[kolom_numerikal].columns):
    sns.histplot(data = data, x = kolom, kde = True, ax = axes[i])

    # Menambahkan judul untuk masing-masing plot
    judul = "\n".join(textwrap.wrap(f"Plot Histogram dari {deskripsi_kolom_numerikal[i]}", width = 30))
    axes[i].set_title(judul)
    axes[i].title.set_size(12)

    # Mengatur label x
    axes[i].set_xlabel(labels[i])
    axes[i].set_ylabel("Total")

# Mengatur susunan agar tidak berhimpitan
plt.tight_layout()

# Menampilkan plot
plt.show()

"""Gambar di atas dapat diinterpretasikan sebagai berikut.
1. Plot Histogram dari `Konsumsi Air Harian`, `Frekuensi Aktivitas Fisik`, `Lama Pemakaian Gadget` tidak berdistribusi normal.
2. Plot Histogram dari `Tinggi Badan`, `Frekuensi Konsumsi Sayur-Sayuran`, `Frekuensi Konsumsi Makanan Berat` cukup berdistribusi normal.
3. Plot Histogram dari `Usia` dan `Berat Badan` memiliki distribusi data yang miring ke kanan. Artinya, mayoritas data memiliki nilai di bawah rata-rata.

# Multivariate Analysis

## 1. Membandingkan Tingkat Berat Badan Pada Setiap Jenis Kelamin
"""

# Membentuk plot jumlah dalam bentuk bar plot antara tingkat berat badan dengan jenis kelamin
plt.figure(figsize = (8, 6))
sns.countplot(x = "NObeyesdad", data = data, hue = "Gender")

# Menambahkan judul pada plot
plt.title("Jumlah Masing-Masing Tingkat Berat Badan Berdasarkan Jenis Kelamin")

# Menambahkan label sumbu x dan y pada plot
plt.xticks(rotation = 90)
plt.xlabel("Tingkat Berat Badan")
plt.ylabel("Jumlah")

# Menampilkan plot
plt.show()

"""Dari gambar di atas, dapat disimpulkan bahwa
1. Laki-laki lebih banyak memiliki berat badan berlebih tingkat 2 dan obesitas tingkat 1 dibandingkan perempuan.
2. Hampir seluruh obesitas tingkat 2 dialami oleh laki-laki, sedangkan hampir seluruh obesitas tingkat 3 dialami oleh perempuan.

## 2. Membandingkan Tingkat Berat Badan dengan Usia
"""

# Membentuk plot strip antara tingkat berat badan dengan usia
plt.figure(figsize = (8, 6))
sns.stripplot(data = data, x = "Age", y = "NObeyesdad")

# Menambahkan judul pada plot
plt.title("Plot Strip Antara Tingkat Berat Badan dengan Usia")

# Menambahkan label sumbu x dan y pada plot
plt.xlabel("Usia (tahun)")
plt.ylabel("Tingkat Berat Badan")

# Menampilkan plot
plt.show()

"""Dari gambar di atas, disimpulkan bahwa
1. Seluruh penyandang obesitas tingkat 3 berusia di bawah 30 tahun.
2. Seluruh penyandang obesitas tingkat 2 berusia di sekitar rentang 20-40 tahun.

## 3. Membandingkan Tingkat Berat Badan dengan Jumlah Makan Berat
"""

# Membentuk plot strip antara tingkat berat badan dengan usia
plt.figure(figsize = (8, 6))
sns.stripplot(data = data, x = "NCP", y = "NObeyesdad")

# Menambahkan judul pada plot
plt.title("Plot Strip Antara Tingkat Berat Badan dengan Jumlah Makan Berat")

# Menambahkan label sumbu x dan y pada plot
plt.xlabel("Frekuensi Jumlah Makan Berat Dalam Sehari")
plt.ylabel("Tingkat Berat Badan")

# Menampilkan plot
plt.show()

"""Dari gambar di atas, disimpulkan bahwa
1. Seluruh penyandang obesitas tingkat 3 makan berat sebanyak 3 kali dalam sehari.
2. Penyandang obesitas tingkat 1 makan berat sebanyak rentang 1-3 kali dalam sehari.
3. Seluruh responden selain poin nomor 1 dan 2 memiliki jumlah makan berat yang bervariasi, dari rentang 1-4 kali makan dalam sehari.

## 4. Membandingkan Tingkat Berat Badan dengan Frekuensi Aktivitas Fisik
"""

# Membentuk plot strip antara tingkat berat badan dengan usia
plt.figure(figsize = (8, 6))
sns.stripplot(data = data, x = "FAF", y = "NObeyesdad")

# Menambahkan judul pada plot
plt.title("Plot Strip Antara Tingkat Berat Badan dengan Frekuensi Aktivitas Fisik")

# Menambahkan label sumbu x dan y pada plot
plt.xlabel("Frekuensi Aktivitas Fisik Dalam Seminggu")
plt.ylabel("Tingkat Berat Badan")

# Menampilkan plot
plt.show()

"""Keterangan
* 0 = Tidak pernah
* 1 = 1-2 hari
* 2 = 3-4 hari
* 3 = 5-6 hari

Dari gambar di atas, disimpulkan bahwa penyandang obesitas tingkat 2 dan tingkat 3 melakukan aktivitas fisik kurang dari 3-4 hari dalam seminggu.

## 5. Membandingkan Tingkat Berat Badan dengan Frekuensi Konsumsi air
"""

# Membentuk plot strip antara tingkat berat badan dengan usia
plt.figure(figsize = (8, 6))
sns.stripplot(data = data, x = "CH2O", y = "NObeyesdad")

# Menambahkan judul pada plot
plt.title("Plot Strip Antara Tingkat Berat Badan dengan Frekuensi Konsumsi Air Dalam Sehari")

# Menambahkan label sumbu x dan y pada plot
plt.xlabel("Frekuensi Konsumsi Air Dalam Sehari (liter)")
plt.ylabel("Tingkat Berat Badan")

# Menampilkan plot
plt.show()

"""Dari gambar di atas, disimpulkan bahwa seluruh responden di setiap tingkat berat badan memiliki frekuensi konsumsi air yang beragam, dengan rentang 1-3 liter dalam sehari.

## 6. Membandingkan Tingkat Berat Badan dengan Konsumsi Makanan Di Antara Makan Berat
"""

# Membentuk plot dsitribusi antara tingkat berat badan dengan konsumsi makanan di antara makan berat
plot_six = sns.displot(data, x = "Weight", hue = "CAEC", multiple = "stack", col = "Gender", height = 4)

# Mengubah letak legend
sns.move_legend(plot_six, "upper left", bbox_to_anchor = (1, 0.75))

# Menambahkan judul untuk seluruh plot
plt.suptitle('Distribusi Berat Badan Terhadap Jumlah Makan Di Antara Makan Berat per Jenis Kelamin', fontsize = 12)

# Menambahkan label sumbu x dan y pada plot
for ax in plot_six.axes.flat:
    ax.set_xlabel("Berat Badan")
plot_six.set(ylabel = "Jumlah")

# Mengatur susunan agar tidak berhimpitan
plt.tight_layout()

# Menampilkan plot
plt.show()

"""Dari gambar di atas, disimpulkan bahwa
1. Mayoritas responden baik laki-laki maupun perempuan terkadang makan di antara makanan berat.
2. Responden yang sering atau selalu makan di antara makanan berat memiliki berat badan kurang dari 120 kilogram.
3. Lebih banyak laki-laki yang sering makan di antara makanan berat dan memiliki berat badan di atas 60 kilogram dibandingkan perempuan.

## 7. Membandingkan Tingkat Berat Badan dengan Jenis Transportasi yang Digunakan
"""

# Membentuk bar plot bertumpuk antara tingkat berat badan dengan jenis transportasi yang digunakan
plt.figure(figsize = (8, 6))
plot_seven = sns.histplot(data = data, x = "NObeyesdad", hue = "MTRANS", legend = True,
                          multiple = "stack", palette = sns.color_palette("bright"))

# Menambahkan judul pada plot
plt.title("Plot Bar Bertumpuk dari Jenis Transportasi yang Digunakan Berdasarkan Tingkat Berat Badan")

# Mengubah letak legend
sns.move_legend(plot_seven, "upper left", bbox_to_anchor = (1, 0.75))

# Menambahkan label sumbu x dan y pada plot
plt.xlabel("Tingkat Berat Badan")
plt.xticks(rotation = 90)
plt.ylabel("Jumlah")

# Menampilkan plot
plt.show()

"""Dari gambar di atas, disimpulkan bahwa
1. Mayoritas responden menggunakan transportasi umum sebagai sarana transportasi mereka.
2. Seluruh penyandang obesitas tingkat 3 menggunakan transportasi umum sebagai sarana transportasi mereka.

## 8. Membandingkan Tingkat Berat Badan dengan Frekuensi Konsumsi Alkohol
"""

# Membentuk bar plot bertumpuk antara tingkat berat badan dengan frekuensi konsumsi alkohol
plt.figure(figsize = (8, 6))
plot_eight = sns.histplot(data = data, x = "NObeyesdad", hue = "CALC", legend = True,
                          multiple = "stack", palette = sns.color_palette("bright"))

# Menambahkan judul pada plot
plt.title("Plot Bar Bertumpuk dari Frekuensi Konsumsi Alkohol Berdasarkan Tingkat Berat Badan")

# Mengubah letak legend
sns.move_legend(plot_eight, "upper left", bbox_to_anchor = (1, 0.75))

# Menambahkan label sumbu x dan y pada plot
plt.xlabel("Tingkat Berat Badan")
plt.xticks(rotation = 90)
plt.ylabel("Jumlah")

# Menampilkan plot
plt.show()

"""Dari gambar di atas, disimpulkan bahwa
1. Mayoritas responden terkadang mengonsumsi alkohol.
2. Seluruh penyandang obesitas tingkat 3 terkadang mengonsumsi alkohol.

## 9. Melihat Korelasi Variabel dengan Menggunakan Heatmap

Selanjutnya, kita akan mencari variabel numerik yang mempengaruhi berat badan seseorang.
"""

# Mencari korelasi antara masing-masing variabel numerik dengan korelasi pearson
corr = data.corr(method = "pearson", numeric_only = True)

# Membentuk heatmap antara masing-masing variabel numerik dan ditampilkan dalam bentuk desimal 2 angka di belakang koma
plt.figure(figsize = (8, 6))
sns.heatmap(corr, annot = True, fmt = ".2f", annot_kws = {"size": 10})

# Menambahkan judul pada plot
plt.title("Heatmap dari Korelasi Antara Masing-Masing Variabel Numerik")

# Menampilkan plot
plt.show()

"""Dari heatmap di atas, dapat dilihat bahwa berat badan responden memiliki
1. Korelasi positif yang cukup kuat dengan tinggi badan.
2. Korelasi positif yang lemah terhadap usia, frekuensi konsumsi sayur-sayuran dalam sehari, dan frekuensi konsumsi air dalam sehari.
3. Korelasi positif yang sangat lemah terhadap frekuensi konsumsi makanan berat.
4. Korelasi negatif yang sangat lemah terhadap frekuensi aktivitas fisik dalam seminggu dan waktu pemakaian gadget dalam sehari.

## 10. Melihat Plot Scatter yang Memiliki Nilai Korelasi $\geq$ 0.2 dari Berat Badan
"""

# Membentuk plot dengan subplot sejumlah 4 berukuran 2 x 2
fig, axes = plt.subplots(2, 2, figsize = (10, 10))

# Mengubah array multi dimensi menjadi array 1 dimensi
axes = axes.flatten()

# Menambahkan satuan dari masing-masing kolom
labels = ["Meter", "Tahun", "Frekuensi", "Liter"]

# Membentuk dictionary dari variabel yang memiliki nilai korelasi lebih dari / sama dengan 0.2
data_x = {0: "Height", 1: "Age", 2: "FCVC", 3: "CH2O"}

# Mendeskripsikan kolom-kolom numerikal yang akan digunakan berdasarkan dictionary di atas
deskripsi_kolom = ["Tinggi Badan",
                   "Usia",
                   "Frekuensi Konsumsi Sayur-Sayuran Harian",
                   "Frekuensi Konsumsi Air Harian"]

# Membentuk plot scatter untuk masing-masing kolom beserta garis trend
for keys, values in data_x.items():
    sns.scatterplot(data = data, x = values, y = "Weight", hue = "Gender", ax = axes[keys])
    sns.regplot(data = data, x = values, y = "Weight", scatter = False, ax = axes[keys], color=  "red")

    # Menambahkan judul untuk masing-masing plot
    judul = "\n".join(textwrap.wrap(f"Plot Scatter dari Berat Badan Terhadap {deskripsi_kolom[keys]}", width = 50))
    axes[keys].set_title(judul)
    axes[keys].title.set_size(12)

    # Menambahkan label sumbu x dan y pada plot
    axes[keys].set_xlabel(labels[keys])
    axes[keys].set_ylabel("Berat Badan")

# Mengatur susunan agar tidak berhimpitan
plt.tight_layout()

# Menampilkan plot
plt.show()

"""Seperti pada nomor 9, dapat dilihat bahwa terdapat
* Korelasi positif yang cukup kuat dengan tinggi badan karena garis trend mengarah ke arah kanan atas.
* Korelasi positif yang lemah terhadap usia, frekuensi konsumsi sayur-sayuran dalam sehari, dan frekuensi konsumsi air dalam sehari karena garis trend mengarah sedikit ke arah kanan atas.

# Data Preprocessing

Akan dilakukan encoding terhadap seluruh data kategorikal agar seluruh data merupakan data numerik.

## Encoding Kategorikal

Encoding Kategorikal dilakukan terhadap 4 variabel, yaitu
* `family_history_with_overweight` (Apakah terdapat anggota keluarga responden yang juga terkena obesitas)
* `FAVC` (Apakah responden mengonsumsi makanan berkalori tinggi)
* `SMOKE` (Apakah responden merupakan perokok)
* `SCC` (Apakah responden memantau asupan kalori)

karena kategori-kategori pada keempat variabel tersebut hanya berisi antara `yes` (iya) dan `no` (tidak)
"""

# Membuat list kolom-kolom kategorikal yang memiliki entri antara yes dan no
Encoding_Kategorikal = ["family_history_with_overweight", "FAVC", "SMOKE", "SCC"]

# Mengubah nilai yes menjadi 1 dan nilai no menjadi 0 pada seluruh kolom tersebut
for kategori in Encoding_Kategorikal:
    data[kategori] = data[kategori].map({"yes": 1, "no": 0})

"""## One Hot Encoding

One Hot Encoding dilakukan terhadap 2 variabel, yaitu

* `MTRANS` (Jenis transportasi yang digunakan)
* `Gender` (Jenis kelamin responden)

karena kategori-kategori pada kedua variabel tersebut tidak memiliki urutan tertentu
"""

# Membentuk kolom dummy dari kolom MTRANS dan Gender
data_encoded = pd.get_dummies(data[["MTRANS", "Gender"]], drop_first = True)

# Menggabungkan data asli dengan data dummy yang telah dibuat
data = pd.concat([data, data_encoded], axis = 1)

# Menghapus kolom MTRANS dan Gender
data.drop(columns = ["MTRANS", "Gender"], inplace = True)

"""## Encoding Ordinal

Encoding Ordinal dilakukan terhadap 2 variabel, yaitu
* CAEC (Konsumsi makanan di antara makan berat)
* CALC (Frekuensi konsumsi alkohol)

karena kategori-kategori pada kedua variabel tersebut memiliki urutan dengan urutannya adalah `['no', 'Sometimes', 'Frequently', 'Always']`
"""

# Mendefinisikan urutan encoding
encoding_order = ["no", "Sometimes", "Frequently", "Always"]

# Membentuk encoding ordinal dengan OrdinalEncoder
ordinal_encoder = OrdinalEncoder(categories = [encoding_order] * 2)

# Mengaplikasikan encoding ordinal untuk kolom CALC dan CAEC
data[["CALC", "CAEC"]] = ordinal_encoder.fit_transform(data[["CALC", "CAEC"]])

# Menampilkan 5 baris pertama dari data setelah dilakukan data preprocessing
data.head()

"""## Data Training dan Testing

Selanjutnya, karena target kita adalah variabel `NObeyesdad` untuk mengetahui akurasi prediksi dari tingkat berat badan, maka kita akan membuang kolom tersebut dari data dan assign kolom tersebut ke variabel baru.
"""

# Membentuk variabel X sebagai pengaruh dari target
X = data.drop(columns = "NObeyesdad")

# Membentuk variabel y sebagai target
y = data["NObeyesdad"]

"""Lalu, kita membagi data menjadi 2, yaitu
* Data training sebesar 80% untuk melatih model
* Data testing sebesar 20% untuk menguji model
"""

# Membentuk data training dan data testing dengan komposisi 80% : 20 % dan dirandom setiap dijalankan ulang
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 50)

# Menampilkan ukuran data training dan testing dari X dan y
print("Ukuran X_train: ", X_train.shape)
print("Ukuran X_test: ", X_test.shape)
print("Ukuran y_train: ", y_train.shape)
print("Ukuran y_test: ", y_test.shape)

"""Lalu, kita akan melihat data training dan testing."""

# Menampilkan 5 baris pertama dari data training X
X_train.head()

# Menampilkan 5 baris pertama dari data testing X
X_test.head()

"""Kemudian, kita melihat jumlah masing-masing tingkat berat badan pada data testing untuk selanjutnya ditransformasikan menggunakan `LabelEncoder()`"""

# Menampilkan nilai-nilai dan jumlah dari variabel target
original_labels = y_test.value_counts()
original_labels

# Membentuk encoding ordinal dengan LabelEncoder
le = LabelEncoder()

# Melakukan fitting terhadap data training dan mentransformasikan data training dan testing
y_train = le.fit_transform(y_train)
y_test = le.transform(y_test)

"""# Pembuatan Model dan Evaluasi

Seluruh model yang akan dibuat tidak menggunakan hyperparameter tuning. Akan dibuat fungsi evaluasi model terlebih dahulu untuk selanjutnya dipanggil untuk masing-masing model.
"""

# Function for evalution report and plotting confusion matrix
def make_evaluation(y_true, y_pred, title):

    # Membuat list nama target yang diinginkan
    target_nama = ['Insufficient_Weight',
                    'Normal_Weight',
                    'Overweight_Level_I',
                    'Overweight_Level_II',
                    'Obesity_Type_I',
                    'Obesity_Type_II',
                    'Obesity_Type_III']

    # Menampilkan laporan klasifikasi (classification report)
    print(classification_report(y_true, y_pred, target_names = target_nama))

    # Membentuk Confusion Matrix
    fig, ax = plt.subplots(figsize = (10, 5))
    disp = ConfusionMatrixDisplay.from_predictions(y_true, y_pred, ax = ax)

    # Menambahkan label sumbu x dan y pada confusion matrix
    ax.xaxis.set_ticklabels(target_nama, rotation = 90)
    ax.yaxis.set_ticklabels(target_nama)

    # Menghilangkan garis-garis grid
    ax.grid(False)

    # Menambahkan judul pada confusion matrix
    _ = ax.set_title(title)
    plt.show()

"""## 1. Menggunakan Algoritma Extreme Gradient Boosting (XGBoost)"""

# Memanggil fungsi XGBClassifier dari library sklearn
model_xgb = XGBClassifier(max_depth = 10, n_estimators = 125,
                          random_state = 30, learning_rate = 0.01, n_jobs = 20)

# Melatih model XGBoost dengan data training pada X dan y
model_xgb.fit(X_train, y_train)

# Memprediksi hasil menggunakan data testing berdasarkan model yang telat dilatih
pred_xgb = model_xgb.predict(X_test)

# Menampilkan akurasi model
xgb = accuracy_score(y_test, pred_xgb)
print(xgb)

# Memanggil fungsi make_evaluation untuk menampilkan f1 score dan confusion matrix
make_evaluation(y_test, pred_xgb, title = f"Confusion Matrix Menggunakan Algoritma XGBoost")

"""Berdasarkan hasil di atas, diperoleh akurasi model XGBoost sebesar $0.933014$ atau $\approx 93.30\%$. Dari confusion matrix, model sedikit salah mengklasifikasi pada obesitas tingkat 2 dan tingkat 3.

## 2. Menggunakan Algoritma Support Vector Machine (SVM)
"""

# Memanggil fungsi SVC dari library sklearn
model_svm = SVC(kernel = 'rbf', gamma = 'auto', random_state = 50)

# Melatih model SVM dengan data training pada X dan y
model_svm.fit(X_train, y_train)

# Memprediksi hasil menggunakan data testing berdasarkan model yang telat dilatih
pred_svm = model_svm.predict(X_test)

# Menampilkan akurasi model
svm = accuracy_score(y_test, pred_svm)
print(svm)

# Memanggil fungsi make_evaluation untuk menampilkan f1 score dan confusion matrix
make_evaluation(y_test, pred_svm, title = f"Confusion Matrix Menggunakan Algoritma SVM")

"""Berdasarkan hasil di atas, diperoleh akurasi model SVM sebesar $0.849282$ atau $\approx 84.93\%$. Dari confusion matrix, model cukup banyak salah mengklasifikasi pada obesitas tingkat 2 dan tingkat 3.

## 3. Menggunakan Algoritma K-Nearest Neighbors (KNN)
"""

# Memanggil fungsi KNeighborsClassifier dari library sklearn
model_knn = KNeighborsClassifier(n_neighbors = 7)

# Melatih model KNN dengan data training pada X dan y
model_knn.fit(X_train, y_train)

# Memprediksi hasil menggunakan data testing berdasarkan model yang telat dilatih
pred_knn = model_knn.predict(X_test)

# Menampilkan akurasi model
knn = accuracy_score(y_test, pred_knn)
print(knn)

# Memanggil fungsi make_evaluation untuk menampilkan f1 score dan confusion matrix
make_evaluation(y_test, pred_knn, title = f"Confusion Matrix Menggunakan Algoritma KNN")

"""Berdasarkan hasil di atas, diperoleh akurasi model KNN sebesar $0.846889$ atau $\approx 84.69\%$. Dari confusion matrix, model banyak salah mengklasifikasi pada berat badan normal.

## 4. Menggunakan Algoritma Random Forest (RF)
"""

# Memanggil fungsi RandomForestClassifier dari library sklearn
model_rf = RandomForestClassifier(n_estimators = 200, criterion = "entropy", max_depth = 10, random_state = 50)

# Melatih model Random Forest dengan data training pada X dan y
model_rf.fit(X_train, y_train)

# Memprediksi hasil menggunakan data testing berdasarkan model yang telat dilatih
pred_rf = model_rf.predict(X_test)

# Menampilkan akurasi model
rf = accuracy_score(y_test, pred_rf)
print(rf)

# Memanggil fungsi make_evaluation untuk menampilkan f1 score dan confusion matrix
make_evaluation(y_test, pred_rf, title = f"Confusion Matrix Menggunakan Algoritma Random Forest")

"""Berdasarkan hasil di atas, diperoleh akurasi model Random Forest sebesar $0.942584$ atau $\approx 94.26\%$. Dari confusion matrix, model sedikit salah mengklasifikasi pada obesitas tingkat 2 dan tingkat 3.

## 5. Menentukan Model Terbaik

Setelah dibentuk 4 model machine learning, selanjutnya akan ditentukan model terbaik dari keempat model tersebut.
"""

# Membentuk DataFrame berisi model dengan akurasinya
models = pd.DataFrame({
    "Model": ["XGBoost", "SVM", "KNN", "Random Forest"],
    "Akurasi": [xgb, svm, knn, rf]
})

# Mengurutkan data berdasarkan akurasi dari tertinggi ke terendah
models.sort_values(by = "Akurasi", ascending = False)

"""Dari DataFrame di atas, dapat dilihat bahwa algoritma Random Forest memiliki akurasi terbaik yaitu $0.942584$ atau $\approx 94.26\%$, sementara algoritma KNN memiliki akurasi terendah yaitu $0.846890$ atau $\approx 84.69\%$. Meski belum sempurna 100%, namun model ini sudah bagus mendeteksi tingkat berat badan mengingat data yang digunakan masih sedikit serta sudah dapat mendeteksi tingkat berat badan pada golongan berat badan berlebih dan obesitas, yang mana ini menjadi permasalahan utama pada analisis ini.

Selanjutnya, dibentuk bar plot dari data tersebut untuk memvisualisasikan data.
"""

# Membentuk plot bar antara tingkat berat badan dengan usia
plt.figure(figsize = (8, 6))
barplot = sns.barplot(data = models, x = "Model", y = "Akurasi", palette = "viridis")

# Menambahkan label angka di atas bar plot pada masing-masing model
for index, value in enumerate(models["Akurasi"]):
    barplot.text(index, value + 0.01, f"{value:.4f}", color = "black", ha = "center")

# Menambahkan judul pada plot
plt.title("Perbandingan Akurasi dari Keempat Model")

# Menambahkan label sumbu x dan y pada plot
plt.xlabel("Model")
plt.ylabel("Akurasi")

# Menampilkan plot
plt.show()